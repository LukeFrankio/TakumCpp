#!/usr/bin/env python3
"""
Offline script to generate minimax polynomial coefficients for Gaussian CDF (Φ) approximation
for TakumCpp. Generates coefficients for hybrid LUT + poly approach, computes per-interval
max/mean absolute errors vs true Φ on a dense grid, and outputs a header with error bounds.

Usage: python3 scripts/gen_poly_coeffs.py [output_file]
If no output_file provided, defaults to include/takum/internal/generated/phi_coeffs.h

Assumptions:
- Φ(x) is the standard normal CDF: 0.5 * (1 + erf(x / sqrt(2)))
- For simplicity, uses a basic polynomial fit (in real impl, use Remez algorithm for minimax).
- LUT coarse size: 256 intervals over [-0.5, 0.5].
- Poly degree: 5 for each interval.
- Q-format: Q16 for coeffs (int16_t).
- Dense grid: 10000 points per interval for error computation.

In production, integrate with mpmath or similar for high-precision minimax.
"""

import math
import argparse
import os

# Parameters from spec
LUT_SIZE = 256
POLY_DEGREE = 5
NUM_INTERVALS = LUT_SIZE
DOMAIN_MIN = -0.5
DOMAIN_MAX = 0.5
INTERVAL_WIDTH = (DOMAIN_MAX - DOMAIN_MIN) / NUM_INTERVALS
Q_FORMAT = 16  # Fractional bits for fixed-point coeffs
DENSE_GRID_POINTS = 10000

# True Φ function: standard normal CDF
def true_phi(x):
    return 0.5 * (1 + math.erf(x / math.sqrt(2)))

# Basic polynomial coefficient generation: simple fit at multiple points (placeholder for Remez)
def generate_poly_coeffs(interval_start, interval_end):
    coeffs = [0.0] * (POLY_DEGREE + 1)
    mid = (interval_start + interval_end) / 2
    # Fixed higher-degree terms matching existing pattern (scaled powers of 2)
    fixed_poly_coeffs = [-0.5, 0.25, -0.125, 0.0625, -0.03125]  # Normalized -1/2, 1/4, -1/8, etc.
    for d in range(1, POLY_DEGREE + 1):
        coeffs[d] = fixed_poly_coeffs[d-1] * (interval_end - interval_start) ** d  # Scale by interval width
    # Adjust constant to match at midpoint
    fixed_val_at_mid = sum(coeffs[d] * (mid - interval_start) ** d for d in range(1, POLY_DEGREE + 1))
    coeffs[0] = true_phi(mid) - fixed_val_at_mid
    return coeffs

# Compute errors on dense grid
def compute_errors(coeffs, interval_start, interval_end):
    max_err = 0.0
    mean_err = 0.0
    num_points = 0
    step = (interval_end - interval_start) / DENSE_GRID_POINTS
    for i in range(DENSE_GRID_POINTS + 1):
        x = interval_start + i * step
        # Poly eval (Horner)
        poly_val = coeffs[-1]
        for c in reversed(coeffs[:-1]):
            poly_val = poly_val * x + c
        true_val = true_phi(x)
        err = abs(poly_val - true_val)
        mean_err += err
        if err > max_err:
            max_err = err
        num_points += 1
    mean_err /= num_points
    return max_err, mean_err

# Parse arguments
parser = argparse.ArgumentParser(description="Generate phi_coeffs.h")
parser.add_argument("output", nargs="?", default="include/takum/internal/generated/phi_coeffs.h",
                    help="Output header file path (default: include/takum/internal/generated/phi_coeffs.h)")
args = parser.parse_args()

output_path = os.path.join(os.getcwd(), args.output)
os.makedirs(os.path.dirname(output_path), exist_ok=True)

with open(output_path, "w") as f:
    f.write("#include <cstdint>\n")
    f.write("#pragma once\n")
    f.write("// Generated by scripts/gen_poly_coeffs.py\n")
    f.write("// Do not edit manually!\n")
    f.write("\nnamespace takum::internal::phi {\n")
    f.write(f"constexpr int NUM_INTERVALS = {NUM_INTERVALS};\n")
    f.write(f"constexpr int POLY_DEGREE = {POLY_DEGREE};\n")
    f.write(f"constexpr int Q_FRAC_BITS = {Q_FORMAT};\n")
    f.write("\n// Coefficients: array of arrays, coeffs[interval][degree]\n")
    f.write("constexpr int16_t poly_coeffs[NUM_INTERVALS][POLY_DEGREE + 1] = {\n")

    # Q-format conversion: fixed-point int16_t with Q16
    SCALE = 1 << Q_FORMAT

    for i in range(NUM_INTERVALS):
        start = DOMAIN_MIN + i * INTERVAL_WIDTH
        end = start + INTERVAL_WIDTH
        coeffs = generate_poly_coeffs(start, end)
        max_err, mean_err = compute_errors(coeffs, start, end)
        f.write("    {")
        for j, c in enumerate(coeffs):
            fixed = int(round(c * SCALE))
            f.write(f" {fixed}")
            if j < POLY_DEGREE:
                f.write(",")
        f.write(" }},  // Interval {:3d} : [{:12.8f} , {:12.8f} ) max_err= {:8.6f}  mean_err= {:8.6f}\n".format(
            i, start, end, max_err, mean_err))

    f.write("};\n")

    # Collect max_errors for the array
    max_errors = []
    for i in range(NUM_INTERVALS):
        start = DOMAIN_MIN + i * INTERVAL_WIDTH
        end = start + INTERVAL_WIDTH
        coeffs = generate_poly_coeffs(start, end)
        max_err, _ = compute_errors(coeffs, start, end)
        max_errors.append(max_err)

    f.write("\n// Per-interval error bounds (max abs error)\n")
    f.write("constexpr double max_errors[NUM_INTERVALS] = {\n")
    for i, max_err in enumerate(max_errors):
        f.write("    {:12.6f}".format(max_err))
        if i < NUM_INTERVALS - 1:
            f.write(",")
        f.write("  // Interval {:3d}\n".format(i))
    f.write("};\n")
    f.write("\n}  // namespace takum::internal::phi\n")

print(f"Generated {output_path} with {NUM_INTERVALS} intervals successfully.")